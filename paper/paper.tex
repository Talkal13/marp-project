\documentclass{article}
\usepackage{mathtools}
\usepackage{csquotes}
\usepackage{graphicx}
\usepackage{listings}

\DeclarePairedDelimiter\abs{\lvert}{\rvert}%
\title{Practica de Métodos Algorítmicos de Resolución de Problemas}
\author{Pablo Vazquez Gomis  \\
	Universidad Complutense de Madrid \\
	}

\date{\today}

\begin{document}

\maketitle


\begin{abstract}
Practica opcional del primer cuatrimestre para la asignatura de Métodos Algorítmicos de Resolución de Problemas.
\end{abstract}

\section{Introducción}
\subsection{Descripción de la práctica}
Implementar o Java o en C++ un algoritmo, que dado un grafo dirigido, detecte si tiene o no
ciclos. En caso de ser acíclico, ha de listar sus vértices en orden topológico. Si hay más de uno
posible, los puede listar en cualquiera de ellos. En caso de ser cíclico, ha de listar sus componentes
fuertemente conexas (cada una es un conjunto de vértices). El algoritmo para esta segunda parte
puede verse en el Capítulo 22 del Cormen (2001, segunda edición).

\subsection{Implementación}

La práctica se puede dividir en 3 partes diferenciales:
\begin{enumerate}
\item \label{1} Comprobar si un grafo es cíclico o no
\item \label{2} los vértices en orden topológico
\item Listar los componentes fuertemente conexos 
\end{enumerate}

\paragraph{}Dado que en al ordenar los vértices de el punto 2 uno de los casos base devuelve error si el
grafo es cíclico y su complejidad esta en orden $ O(\abs{V} + \abs{E}) $ utilizaremos esa función para comprobar el punto 1.

\paragraph{}En caso positivo, habremos encontrado una solución al punto 1 en orden $ O(\abs{V} + \abs{E}) $. En caso negativo, tendremos la solución al punto 2
en el mismo orden.

\paragraph{}Para resolver el punto 3 utilizamos el algoritmo de Tarjan\cite{tarjan} para encontrar componentes fuertemente conexas,
el cual resuelve el problema utilizando \textit{Depth First Search (DFS)} con una complejidad de $ O(\abs{V} + \abs{E}) $.

\section{Ordenación topológica}
\paragraph{Definición:}Usando la definición propuesta por A. B. Kahn\cite{kahn}:
\begin{displayquote}
A list in topological order is such that no element appears in it until after all elements appearing on all paths leading to the particular element have been listed. 
\end{displayquote}
En otras palabras, dado que es necesario que el grafo sea acíclico para poder ordenarlo topológicamente, el raíz del grafo sera el primer elemento de la lista ordenada
y los elementos siguientes serán la ordenación topológica de sus hijos.
\paragraph{Implementación:} Usando DFS, podemos recorrer la lista desde una raíz del grafo cualquiera hasta el final de un camino,
Continuando esta estrategia, la lista se compondrá recursivamente:
\[ vertice + dfsTopologicalSort(e) \mid \forall e \in node.edges \] 
Esto se consigue, añadiendo el nodo a la lista en primera posición cuando todas su aristas han sido visitadas.
\section{Componentes fuertemente conexos}
\paragraph{Definición:} Dado un grafo dirigido G, supongamos que para cada par de vértices v,w
existe los caminos: $p_1: v \Rightarrow w$ y $p_2: w \Rightarrow v$, entonces G es fuertemente conexo.
\paragraph{Implementación:} El problema lo resolveremos con el algoritmo propuesto por Robert E. Tarjan\cite{tarjan}, el cual se basa en estos puntos:
\begin{enumerate}
	\item Usando \textit{DFS} busca por todos los nodos siguiendo los caminos del grafo, asignando un indice y un \textbf{lowpoint-index} único a cada uno la primera vez que se visita el nodo.
	\item El \textbf{lowpoint-index} representa el índice del nodo mas bajo al que se puede llegar siguiendo los caminos desde el nodo inicial y se va actualizando en el backtranking de
\textit{DFS}.
	\item Cuando el siguiendo un camino, se llega a el nodo inicial, todos los nodos que tengan el mismo \textbf{lowpoint-index} son nodos pertenecientes a el componente fuertemente conexos
	\item Para evitar que el algoritmo dependa de el nodo inicial, que se elige aleatoriamente, se lleva la cuenta de los nodos recorridos con un stack. A la hora de recuperar componentes fuertemente conexas,
solo los nodos que están en el stack pertenecen a él.
\end{enumerate}
\section{Ejecuciones Sencillas}
\begin{lstlisting}[caption=resources/graph1.txt, frame=shadowbox]
	Cycle number 0
	0
	Cycle number 1
	4
	Cycle number 2
	3 -> 1 -> 2
	Time to complete tarjan: 0.027
	Time to complete cycles search: 0
\end{lstlisting}

\begin{lstlisting}[caption=resources/graph2.txt, frame=shadowbox]
	1 - 2 - 3 - 4 - 5 - 6
	Time to complete topological sort: 0.039
	Time to complete cycles search: 0.009
\end{lstlisting}

\begin{lstlisting}[caption=resources/graph3.txt, frame=shadowbox]
	Cycle number 0
	0 -> 1 -> 2
	Cycle number 1
	6 -> 4 -> 5
	Cycle number 2
	7 -> 3
	Time to complete tarjan: 0.187
	Time to complete cycles search: 0.012
\end{lstlisting}
\section{Gráficas}\label{graphs}
Todas las gráficas se encuentran en el apéndice de este documento.
\subsection{Observaciones}
Como se puede observar en las gráficas, el algoritmo de Tarjan\cite{tarjan} crece de forma mas rápida
el algoritmo de para ordenar topológicamente la lista, esto aparenta ser debido a el coste acumulado de las operaciones sobre vectores y listas.
\paragraph{}Esta conclusión es inferida de la comparación entre la búsqueda en de ciclos y la ordenación topológica. Ambos hacen esencialmente la misma búsqueda en profundidad, salvo por una pequeña operación de almacenaje en el stack
pero sin embargo, como podemos observar en la figura uno, la búsqueda topológica crece de manera mas veloz que el algoritmo de búsqueda.
\paragraph{}Con el algoritmo de Tarjan\cite{tarjan} ocurre exactamente lo mismo pero aumentado dado que además de mantener el stack de llamadas, hemos de ir añadiendo a la lista de componentes.
\paragraph{Conclusión} Aunque las operaciones con las estructuras de datos no añaden a la complejidad del algoritmo, si que se ven reflejadas en los tiempos de ejecución.
\begin{thebibliography}{9}
\bibitem{tarjan} Robert E. Tarjan. \textit{Depth-First Search and Linear Graph Algorithms}.
Stanford University. Stanford, California.
\bibitem{kahn} A. B. Kahn. \textit{Topological sorting of large networks}. Westinghouse Electric Corporation, Baltimore, Maryland
\end{thebibliography}
\section{Apendice}
\appendix
\begin{figure}[h!]
	\centering
	  	\includegraphics[width=\linewidth, height=0.40\textheight]{../graphs/graph-dac-1}
	\label{fig-dac-1}
\end{figure}
\paragraph{} 
\begin{figure}[h!]
	\centering
		  \includegraphics[width=\linewidth, height=0.40\textheight]{../graphs/graph-rand-5}
	\label{fig-rand-5}
\end{figure}
\begin{figure}[h!]
	\centering
	  	\includegraphics[width=\linewidth,height=0.40\textheight]{../graphs/graph-rand-6}
	\label{fig-rand-6}
\end{figure}
\end{document} 